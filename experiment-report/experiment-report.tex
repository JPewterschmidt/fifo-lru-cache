\maketitle

\begin{abstract}
    本实验分别实现了传统LRU淘汰算法在单线程以及单把锁的多线程版本，用于展示lock contention对性能的影响。
    另外实现了基于无锁队列和智能指针的近似LRU算法、
    类似于Redis方案的采样LRU算法。
    本实验分别对不同线程数量、不同缓存容量以及不同缓存访问行为三个角度出发对上述三种缓存进行性能测试。
    报告还介绍了本实验的三种缓存的部分实现细节以及其对性能的影响，最后还有本人对系统方向优化工作的感想。
    
    \textbf{关键字:}\quad LRU\quad 采样LRU\quad lock-free\quad 无锁队列\quad 并发编程
\end{abstract}

\section{实验报告}

\subsection{实验平台}

本实验设计中开发、性能测试均在具备以下软硬件的系统上进行：
\begin{itemize}
    \item Intel Core I7 8750H 2.20GHz $\sim$ 4.10GHz
    \item 16GB DDR4 2667MHz
    \item 192 KB L1d, 192 KB L1i, 1.5M L2, 9M L3
    \item Linux 6.6.47-gentoo-dist x86\_64 GNU/Linux
    \item gcc version 14.2.1 20240817 (Gentoo 14.2.1\_p20240817 p4)
\end{itemize}

实验采用xmake作为构建系统，
使用的与本实验主题相关的开源软件在参考文献中列出。
使用的其他软件请参见\verb|xmake.lua|文件。
报告本身使用 \LaTeX 编写。编译运行实验代码、编译本报告可通过以下命令完成：
\begin{verbatim}
git submodule update --recursive --remote --init
xmake f -m release; xmake -j 12; xmake r
\end{verbatim}

\subsection{实现细节}

所有实现中使用的Hash算法均为 MurmurHash3 中的x64版本，输出的是128位Hash值。
本实验对其输出的128位Hash值做\verb|h[0] ^ (h[1] << 1)|处理以适应所使用的HashMap对象的要求。
单线程版本的LRU缓存使用\verb|std::unordered_map|作为hash索引，
其他两个无锁LRU缓存使用\verb|libcuckoo::cuckoohash_map|作为hash索引。

\subsubsection{单线程LRU缓存}

单线程LRU缓存(后称N方案，Na\"{i}ve-LRU)实现了严格的LRU淘汰算法，
直接使用STL \verb|std::list| 存储缓存数据.
在hash表中存储各节点对应迭代器。节点的提升操作使用如下代码实现 
\begin{verbatim}
m_cache_list.splice(m_cache_list.begin(), m_cache_list, it->second);
\end{verbatim}
其中 \verb|it->second| 是指向该链表节点的迭代器，该操作将它指向的节点的位置关系移动到
\verb|m_cache_list.begin()|之前，所包含的元素并不会发生移动或拷贝。

\subsubsection{无锁队列近似LRU}

该算法使用一个无锁队列模拟LRU算法（后称Q方案Queue-LRU）。
实现中，每个元素使用 \verb|std::shared_ptr| 管理，
无锁队列保存表示元素的智能指针，另在hash表中保存对应指针的 \verb|std::weak_ptr|.

节点的\textbf{提升操作}直接在队列头部插入指向该元素的智能指针，
本文称这种操作为冗余提升\footnote{出于队列的限制，并不从队列中部移除原先的节点。}。
以保证元素不被移出内存。

为了减少冗余指针的内存浪费，
在冗余提升之前必须“淘汰”一个元素，
类似的，本文称该操作为滞后淘汰。
其滞后性体现在该智能指针对象的副本有可能因为冗余提升仍留存在队列中，
因此此时还不合适将被缓存内容移除出内存，也不应从hash索引中移除。

该算法通过智能指针的引用计数大致判断当前节点是否需要滞后淘汰，
但这种做法不保证绝对的准确性。
C++标准并未规定 \verb|use_count()| 函数内部使用何种原子操作内存序访问引用计数，
因此不能对该调用反馈的引用计数值的准确性做任何假设，即它是不准确的。
但因为热数据一定会被多次冗余提升，因此在队列中一定包含多个冗余的智能指针对象，
因此基于 \verb|use_count()| 返回值的淘汰策略很难误伤真正的热数据。

应用代码中有可能会持有多份某对象的指针副本，
这种罕见的情况造成的误判导致缓存不从hash索引中移除它，
即使在队列中已不包含该指针副本。
但换个角度来看，这种情况反应数据仍有部分热度。
一段时间后所有应用代码释放对其的引用，
在hash表中的 \verb|std::weak_ptr| 也不会阻止缓存内容被移出内存。
这也反映了该淘汰算法的滞后性。

\textbf{插入新节点}同样在对头插入新的指针，
但与此同时也向内存载入了新的应用数据。
为了严格控制应用数据的内存消耗，一定要淘汰掉一个真正的旧数据。
可以通过重复执行上文算法来达到这一目的。

\subsubsection{无锁采样近似LRU}

本实验复现了 Redis 中的采样LRU算法（后称S方案，Sampling-LRU），并为其添加了无锁并发支持。

为了支持随机采样，本实现实现了支持随机访问的对象池，
该对象池以块(chunk)为单位管理内存\footnote{一个块通常为4096B}，不保证内存的连续性。
采样算法随机给出的元素下标对应内存位置若未被分配，则返回一个空指针。
下游系统 Deallocate 操作将会把当前对象所占内存放入一个无锁队列中回收，
下次 Allocate 操作优先从回收队列中获取。

系统维护一个32位无符号整形变量作为LRU Clock，
每次对缓存的访问都会使得Clock 原子地增1来表示时间的变化。
每个缓存节点包含节点上次访问时刻，节点当前被采样状态等字段。
其中节点上次访问时刻为一个32位无符号整数，用于表达元素之间的新旧关系。
由于大致计算不同节点间的老旧关系并无需准确的数据，
因此对该字段的更新和读取以及对LRU Clock的访问全部使用 \verb|relaxed| 内存序，
以尽可能减少原子操作对性能的负面影响。

节点的\textbf{提升操作}将会给其上次访问时刻赋最新LRU Clock值，
相比前两种通过变化数据结构内部节点位置关系的方式，仅需要 \verb|relaxed|地原子修改一个内存位置。

\textbf{插入新节点}需要从对象池中申请一块内存，在上面构造后赋予当前访问时间，并插入到hash表中。
当空间不足时，执行采样算法选取若干待决定元素，从中选取距离本次访问最旧的对象淘汰。
采样通过服从均匀分布的随机整数生成器生成若干在区间$\allowbreak (0, \mbox{Number of cached})$
的整数作为采样下标，并通过该下标从对象池中获取该对象存储区域的指针。
采样算法对当前时刻分别与两个待决定对象的上次访问时刻做差并对两者进行比较来区分出两者的新旧关系。
通过对做差结果取模，可以消除溢出对数据带来的影响。

\subsection{设计思路}

Q 方案的设计初衷是用无锁链表和无锁hash表达到免除锁的目的。
但是在实现过程中发现，双链表难以通过原子CAS操作在分离某节点时继续维持双链表关系，
要达到像单线程双链表一样的效果需要DCAS或CAS2\footnote{能原子地修改两个内存位置的CAS操作}操作，
但所有现代CPU均不支持该操作。

因此Q方案放弃提升操作中先从链表中删除节点的步骤，转而采用上文中提出的冗余提升。
核心思想就是相比N方案\textbf{宽松}淘汰算法中提升操作的要求。
由于冗余提升的缘故，必然导致队列中存在冗余智能指针，因此淘汰操作被称为滞后淘汰。
这种提升和淘汰方案在运行时速度表现良好，但内存用量则无法严格控制在给定的缓存大小内。

S 方案是在Redis采样LRU算法的基础上，对其增加并发支持。
该方案操作简洁，核心思想是\textbf{宽松}淘汰对象的选取准确性要求。
该操作在Q方案和N方案中都是从队列或者链表尾部选取\textbf{最}久未使用的对象。
维持这个待淘汰对象的\textbf{最}字需要链表以及队列的操作修改多个指针值来维持链表和队列的元素关系。
优点是精准确定被淘汰对象，缺点是写放大效应相对较严重。
而S方案仅需要原子地修改一个上次访问时刻即可，而且该原子操作对准确性要求不高，使用 \verb|relaxed|内存序即可。
相比之下维持对象间新旧关系造成的写放大效应理论上要小于上两种算法。
而且使用对象池管理内存更容易严格控制缓存的内存消耗。

综上所述，除了N方案作为体现锁是多么邪恶的存在以外，另外两种方案均对LRU算法中某个步骤进行\textbf{宽松}。
追求的不再是微观上的准确，而是宏观上的准确。这一变化为无锁并发编程减少了许多负担。

\subsection{实验设计}

本小节对上述LRU方案从命中率、吞吐量以及内存消耗三个维度进行性能测试。
并分析三种方案中并发管理占总时间消耗的比例。

\subsubsection{命中率}

命中率测试数据分别使用 Zipfian 分布和 Uniform 分布来模拟局部性好和扫描缓存使用场景，
观察不同线程数对命中率的影响。




